import os
import sys
import bosdyn.client
import bosdyn.client.util
from bosdyn.api.autowalk import walks_pb2
from bosdyn.api.graph_nav import graph_nav_pb2, map_pb2, nav_pb2
from bosdyn.api.mission import mission_pb2, nodes_pb2
from bosdyn.client.power import PowerClient, power_on_motors, safe_power_off_motors
from bosdyn.client.robot_command import RobotCommandBuilder, RobotCommandClient, blocking_stand
from bosdyn.client.robot_state import RobotStateClient
import time
import google.protobuf.wrappers_pb2
import bosdyn.mission
from pathlib import Path
import argparse
import os
import sys
import time

import google.protobuf.wrappers_pb2

import bosdyn.api.power_pb2 as PowerServiceProto
import bosdyn.client
import bosdyn.client.lease
import bosdyn.client.util
import bosdyn.geometry
from bosdyn.mission.client import MissionClient, mission_service_pb2_grpc
import bosdyn.util
from bosdyn.api import robot_state_pb2
from bosdyn.api.autowalk import walks_pb2
from bosdyn.api.graph_nav import graph_nav_pb2, map_pb2, nav_pb2
from bosdyn.api.mission import mission_pb2, nodes_pb2
from bosdyn.client.power import PowerClient, power_on_motors, safe_power_off_motors
from bosdyn.client.robot_command import RobotCommandBuilder, RobotCommandClient, blocking_stand
from bosdyn.client.robot_state import RobotStateClient
from bosdyn.api.mission import mission_pb2, nodes_pb2


def stand(robot, lease_client):
    with bosdyn.client.lease.LeaseKeepAlive(lease_client):
        robot.logger.info('Powering on robot... This may take several seconds.')
        robot.power_on(timeout_sec=20)
        assert robot.is_powered_on(), 'Robot power on failed.'
        robot.logger.info('Robot powered on.')

        # Tell the robot to stand up. The command service is used to issue commands to a robot.
        # The set of valid commands for a robot depends on hardware configuration. See
        # RobotCommandBuilder for more detailed examples on command building. The robot
        # command service requires timesync between the robot and the client.
        robot.logger.info('Commanding robot to stand...')
        command_client = robot.ensure_client(RobotCommandClient.default_service_name)
        blocking_stand(command_client, timeout_sec=10)
        robot.logger.info('Robot standing.')
        time.sleep(3)
        robot.power_off(cut_immediately=False, timeout_sec=10)
        assert not robot.is_powered_on(), 'Robot power off failed.'
        robot.logger.info('Robot safely powered off.')

def powerRobot(robot):
    robot.power_on(timeout_sec=10)
    state = robot.is_powered_on()
    if state == True:
        print("Motory spuštěny")

def connectSpot():
    sdk = bosdyn.client.create_standard_sdk('client')
    robot = sdk.create_robot('192.168.80.3')
    robot.authenticate('admin','6k1ad7psb2a5')
    robot.time_sync.wait_for_sync()

    return robot

def acquireEstop(robot):
    estop_client = robot.ensure_client('estop') # zajištění software e-stop
    estop_endpoint = bosdyn.client.estop.EstopEndpoint(client=estop_client, name='my_estop', estop_timeout=9.0)
    estop_endpoint.force_simple_setup()
    estop_keep_alive = bosdyn.client.estop.EstopKeepAlive(estop_endpoint)

def acquireLease(robot):
    lease_client = robot.ensure_client('lease')
    print(lease_client.list_leases())
    lease = lease_client.acquire()

    return lease_client

def playMission(robot, id):
    walk = f'C:/Users/patri/Downloads/SPOT-PY/missions/stul1.walk/missions'
    walk_directory = Path(walk)
    mission_file = Path(f'{walk_directory}/autogenerated.walk')

    # Check if mission_file exists.
    if not os.path.isfile(mission_file):
        robot.logger.fatal(f'Unable to find mission file: {mission_file}.')
        sys.exit(1)
    
     # Acquire robot lease
    robot.logger.info('Acquiring lease...')
    # lease_client = acquireLease(robot)
    lease_client = robot.ensure_client(bosdyn.client.lease.LeaseClient.default_service_name)

    with bosdyn.client.lease.LeaseKeepAlive(lease_client, must_acquire=False, return_at_exit=True):
        # Initialize power client
        robot.logger.info('Starting power client...')
        power_client = robot.ensure_client(PowerClient.default_service_name)

        # Initialize other clients
        robot_state_client, command_client, mission_client, graph_nav_client = init_clients(
            robot, mission_file, walk_directory, do_map_load=True, disable_alternate_route_finding=False,
            upload_timeout=300)

        # Turn on power
        power_on_motors(power_client)

        # Stand up and wait for the perception system to stabilize
        robot.logger.info('Commanding robot to stand...')
        blocking_stand(command_client, timeout_sec=20)
        countdown(5)
        robot.logger.info('Robot standing.')

        # Localize robot
        localization_error = False
        
        graph = graph_nav_client.download_graph()
        robot.logger.info('Localizing robot...')
        robot_state = robot_state_client.get_robot_state()
        localization = nav_pb2.Localization()
        # Attempt to localize using any visible fiducial
        graph_nav_client.set_localization(
            initial_guess_localization=localization, ko_tform_body=None, max_distance=None,
            max_yaw=None,
            fiducial_init=graph_nav_pb2.SetLocalizationRequest.FIDUCIAL_INIT_NEAREST)

        # Run mission
        if not localization_error:
            run_mission(robot, mission_client, lease_client, fail_on_question=True,
                        mission_timeout=3.0, disable_directed_exploration=False)


def countdown(length):
    """Print sleep countdown"""

    for i in range(length, 0, -1):
        print(i, end=' ', flush=True)
        time.sleep(1)
    print(0)

def main():
    robot = connectSpot()
    acquireEstop(robot)

    assert not robot.is_estopped(), 'Robot is estopped. Please use an external E-Stop client, ' \
                                    'such as the estop SDK example, to configure E-Stop.'
    
    # lease_client = acquireLease(robot)

    # Only one client at a time can operate a robot. Clients acquire a lease to
    # indicate that they want to control a robot. Acquiring may fail if another
    # client is currently controlling the robot. When the client is done
    # controlling the robot, it should return the lease so other clients can
    # control it. The LeaseKeepAlive object takes care of acquiring and returning
    # the lease for us.

    # stand(robot, lease_client)
    playMission(robot, 1)

def init_clients(robot, mission_file, walk_directory, do_map_load, disable_alternate_route_finding,
                 upload_timeout):
    """Initialize clients"""

    graph_nav_client = None

    # Create autowalk and mission client
    robot.logger.info('Creating mission client...')
    mission_client = robot.ensure_client(bosdyn.mission.client.MissionClient.default_service_name)
    robot.logger.info('Creating autowalk client...')
    autowalk_client = robot.ensure_client(
        bosdyn.client.autowalk.AutowalkClient.default_service_name)

    if do_map_load:
        if not os.path.isdir(walk_directory):
            robot.logger.fatal(f'Unable to find walk directory: {walk_directory}.')
            sys.exit(1)

        # Create graph-nav client
        robot.logger.info('Creating graph-nav client...')
        graph_nav_client = robot.ensure_client(
            bosdyn.client.graph_nav.GraphNavClient.default_service_name)

        # Clear map state and localization
        robot.logger.info('Clearing graph-nav state...')
        graph_nav_client.clear_graph()

        # Upload map to robot
        upload_graph_and_snapshots(robot, graph_nav_client, walk_directory,
                                   disable_alternate_route_finding, upload_timeout)

        # Here we assume the input file is an autowalk file so we parse it as a walk proto
        # and upload through the autowalk service.
        # If that fails we try parsing as a node and uploading through the mission service.
        try:
            upload_autowalk(robot, autowalk_client, mission_file, upload_timeout)
        except google.protobuf.message.DecodeError:
            robot.logger.warning(
                f'Failed to parse autowalk proto from {mission_file}. Attempting to parse as node proto.'
            )
            upload_mission(robot, mission_client, mission_file, upload_timeout)

    else:
        # Upload mission to robot
        upload_mission(robot, mission_client, mission_file, upload_timeout)

    # Create command client
    robot.logger.info('Creating command client...')
    command_client = robot.ensure_client(RobotCommandClient.default_service_name)

    # Create robot state client
    robot.logger.info('Creating robot state client...')
    robot_state_client = robot.ensure_client(RobotStateClient.default_service_name)

    return robot_state_client, command_client, mission_client, graph_nav_client

def countdown(length):
    """Print sleep countdown"""

    for i in range(length, 0, -1):
        print(i, end=' ', flush=True)
        time.sleep(1)
    print(0)


def upload_graph_and_snapshots(robot, client, path, disable_alternate_route_finding,
                               upload_timeout):
    """Upload the graph and snapshots to the robot"""

    # Load the graph from disk.
    graph_filename = os.path.join(path, 'graph')
    robot.logger.info(f'Loading graph from {graph_filename}')

    with open(graph_filename, 'rb') as graph_file:
        data = graph_file.read()
        current_graph = map_pb2.Graph()
        current_graph.ParseFromString(data)
        robot.logger.info(
            f'Loaded graph has {len(current_graph.waypoints)} waypoints and {len(current_graph.edges)} edges'
        )

    if disable_alternate_route_finding:
        for edge in current_graph.edges:
            edge.annotations.disable_alternate_route_finding = True

    # Load the waypoint snapshots from disk.
    current_waypoint_snapshots = dict()
    for waypoint in current_graph.waypoints:
        if len(waypoint.snapshot_id) == 0:
            continue
        snapshot_filename = os.path.join(path, 'waypoint_snapshots', waypoint.snapshot_id)
        robot.logger.info(f'Loading waypoint snapshot from {snapshot_filename}')

        with open(snapshot_filename, 'rb') as snapshot_file:
            waypoint_snapshot = map_pb2.WaypointSnapshot()
            waypoint_snapshot.ParseFromString(snapshot_file.read())
            current_waypoint_snapshots[waypoint_snapshot.id] = waypoint_snapshot

    # Load the edge snapshots from disk.
    current_edge_snapshots = dict()
    for edge in current_graph.edges:
        if len(edge.snapshot_id) == 0:
            continue
        snapshot_filename = os.path.join(path, 'edge_snapshots', edge.snapshot_id)
        robot.logger.info(f'Loading edge snapshot from [snapshot_filename]')

        with open(snapshot_filename, 'rb') as snapshot_file:
            edge_snapshot = map_pb2.EdgeSnapshot()
            edge_snapshot.ParseFromString(snapshot_file.read())
            current_edge_snapshots[edge_snapshot.id] = edge_snapshot

    # Upload the graph to the robot.
    robot.logger.info('Uploading the graph and snapshots to the robot...')
    true_if_empty = not len(current_graph.anchoring.anchors)
    response = client.upload_graph(graph=current_graph, generate_new_anchoring=true_if_empty,
                                   timeout=upload_timeout)
    robot.logger.info('Uploaded graph.')

    # Upload the snapshots to the robot.
    for snapshot_id in response.unknown_waypoint_snapshot_ids:
        waypoint_snapshot = current_waypoint_snapshots[snapshot_id]
        client.upload_waypoint_snapshot(waypoint_snapshot=waypoint_snapshot, timeout=upload_timeout)
        robot.logger.info(f'Uploaded {waypoint_snapshot.id}')

    for snapshot_id in response.unknown_edge_snapshot_ids:
        edge_snapshot = current_edge_snapshots[snapshot_id]
        client.upload_edge_snapshot(edge_snapshot=edge_snapshot, timeout=upload_timeout)
        robot.logger.info(f'Uploaded {edge_snapshot.id}')


def upload_autowalk(robot, autowalk_client, filename, upload_timeout):
    """Upload the autowalk mission to the robot"""

    # Load the autowalk from disk
    robot.logger.info(f'Loading autowalk from {filename}')

    autowalk_proto = walks_pb2.Walk()
    with open(filename, 'rb') as walk_file:
        data = walk_file.read()
        try:
            autowalk_proto.ParseFromString(data)
        except google.protobuf.message.DecodeError as exc:
            raise exc

    # Upload the mission to the robot
    robot.logger.info('Uploading the autowalk to the robot...')
    autowalk_client.load_autowalk(autowalk_proto, timeout=upload_timeout)
    robot.logger.info('Uploaded autowalk to robot.')


def upload_mission(robot, client, filename, upload_timeout):
    """Upload the mission to the robot"""

    # Load the mission from disk
    robot.logger.info(f'Loading mission from {filename}')

    mission_proto = nodes_pb2.Node()
    with open(filename, 'rb') as mission_file:
        data = mission_file.read()
        mission_proto.ParseFromString(data)

    # Upload the mission to the robot
    robot.logger.info('Uploading the mission to the robot...')
    client.load_mission(mission_proto, timeout=upload_timeout)
    robot.logger.info('Uploaded mission to robot.')


def run_mission(robot, mission_client, lease_client, fail_on_question, mission_timeout,
                disable_directed_exploration, path_following_mode):
    """Run mission once"""

    robot.logger.info('Running mission')

    mission_state = mission_client.get_state()

    while mission_state.status in (mission_pb2.State.STATUS_NONE, mission_pb2.State.STATUS_RUNNING):
        # We optionally fail if any questions are triggered. This often indicates a problem in
        # Autowalk missions.
        if mission_state.questions and fail_on_question:
            robot.logger.info(
                f'Mission failed by triggering operator question: {mission_state.questions}')
            return False

        body_lease = lease_client.lease_wallet.advance()
        local_pause_time = time.time() + mission_timeout

        play_settings = mission_pb2.PlaySettings(
            disable_directed_exploration=disable_directed_exploration,
            path_following_mode=path_following_mode)

        mission_client.play_mission(local_pause_time, [body_lease], play_settings)
        time.sleep(1)

        mission_state = mission_client.get_state()

    robot.logger.info(f'Mission status = {mission_state.Status.Name(mission_state.status)}')

    return mission_state.status in (mission_pb2.State.STATUS_SUCCESS,
                                    mission_pb2.State.STATUS_PAUSED)


def restart_mission(robot, mission_client, lease_client, mission_timeout):
    """Restart current mission"""

    robot.logger.info('Restarting mission')

    body_lease = lease_client.lease_wallet.advance()
    local_pause_time = time.time() + mission_timeout

    status = mission_client.restart_mission(local_pause_time, [body_lease])
    time.sleep(1)

    return status == mission_pb2.State.STATUS_SUCCESS


def repeat_mission(robot, mission_client, lease_client, total_time, fail_on_question,
                   mission_timeout, disable_directed_exploration, path_following_mode):
    """Repeat mission for period of time"""

    robot.logger.info(f'Repeating mission for {total_time} seconds.')

    # Run first mission
    start_time = time.time()
    mission_success = run_mission(robot, mission_client, lease_client, fail_on_question,
                                  mission_timeout, disable_directed_exploration,
                                  path_following_mode)
    elapsed_time = time.time() - start_time
    robot.logger.info(f'Elapsed time = {elapsed_time} (out of {total_time})')

    if not mission_success:
        robot.logger.info('Mission failed.')
        return False

    # Repeat mission until total time has expired
    while elapsed_time < total_time:
        restart_mission(robot, mission_client, lease_client, mission_timeout=3)
        mission_success = run_mission(robot, mission_client, lease_client, fail_on_question,
                                      mission_timeout, disable_directed_exploration,
                                      path_following_mode)

        elapsed_time = time.time() - start_time
        robot.logger.info(f'Elapsed time = {elapsed_time} (out of {total_time})')

        if not mission_success:
            robot.logger.info('Mission failed.')
            break

    return mission_success

if __name__ == "__main__":
    main()